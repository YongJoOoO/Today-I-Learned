# **ch10. 예외 처리**

## **10-1. 예외 클래스**

<aside>
📌 Error : 하드웨어적 문제

Exception : 프로그램 실행 도중 발생 문제

</aside>

**[예외와 예외클래스]**

   **<예외의 종류> 2가지**

- **일반 예외** : 컴파일러 체크 예외

: 컴파일러가 해당 예외처리코드 존재 여부 검사 O

- **실행 예외 :** 컴파일러 넌 체크 예외

: 컴파일러가 검사X

   **<예외 클래스>**

: JVM 은 예외를 클래스로 관리

: JVM 은 실행 도중 예외 발생 시 -> 해당 예외클래스로 객체 생성

: 모든 예외 클래스는 jaca.lang.Exception클래스를 상속받음

**[실행 예외 종류]**

1) **NullPointerException**

🟨 java.lang.NullPotinterException 예외 발생

      : null값 갖는 참조 변수로 객체 접근 시도할 때 발생

2) **ArrayIndexOutOfBoundsException**

🟨java.lang.ArrayIndexOutOfBoundsException 예외 발생

        : 배열 인덱스의 범위 초과하여 사용할 경우 발생

3) **NumberFormatException**

🟨java.lang.NumberFormatException 예외 발생

: 문자열 데이터를 숫자로 변경하는 경우, 매개값에 숫자 변경 불가능한 문자 포함될 때 발생

4) **ClassCastException**

🟨java.lang.ClassCastException 예외 발생

: 타입 변환은 부모 클래스 – 자식 클래스 / 구현 클래스 – 인터페이스 간에서만 발생

: 상속 관계와 구현 관계에 있는 클래스 간의 타입 변환이 아닌 경우, 발생

: 강제타입변환은 자동타입변환 발생한 클래스 간에서만 가능하며, 해당되지 않는 클래스 타입으로 변환 시도할 경우 예외 발생

   → **instanceof연산자**로 먼저 확인 후 강제타입변환 할 것

```java
animal **instanceof** Dog 
```

## **10-2. 예외 처리**

**[예외 처리]**

: 예외 발생 시 프로그램의 갑작스러운 종료를 막고, 정상 실행 유지되도록 역할

: 일반 예외 코드 -> 컴파일러가 강제적으로 예외처리코드 작성을 요구

: 실행 예외 코드 -> 개발자가 알아서 자발적으로 예외처리코드 작성해야 함

**[예외 처리 코드] : try-catch-finally 구문**

```java
try {

	//예외 발생 가능성 코드
} catch (예외클래스이름 e ) {
	//예외 처리 코드
} finally {
	//선택. 항상 실행됨
}
```

**[예외 종류에 따른 처리 코드] : 다중 catch문**

: try 블록 내부에 다양한 예외 가능 코드 작성 가능

: 각 에외별로 예외처리코드 작생 원할 때 다중 Catch문 작성

: catch 블록 예외 클래스 타입을 읽고, try 블록에서 해당 타입의 예외 발생 시

해당 catch 블록 실행시킴

: catch블록 여러 개여도, 단 하나의 catch블록만 실행된다.

( try블록에서는 예외 발생 즉시 멈추고 catch 실행하기 때문. 즉, 다발적으로 예외발생 X )

: 다중 catch 블록 작성 시, 상위예외클래스가 하위예외클래스보다 아래 쪽에 작성되어야 함

**[예외 떠넘기기] : throws**

: throws메소드 내부에서 처리하지 않은 예외를 호출한 곳으로 떠넘기는 역할

```java
리턴타입 메소드이름(매개변수) **throws** 예외클래스1, 예외클래스2 ... { ... }

리턴타입 메소드이름(매개변수) **throws** Exception { ... }
```