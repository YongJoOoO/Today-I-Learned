# **ch08. 인터페이스**

## **08-1. 인터페이스**

**[인터페이스]**

: 개발코드와 객체 사이를 잇는 접점 역할

: 개발코드가 인터페이스의 추상 메소드 호출하면 //

인터페이스는 구현 객체의 재정의된 실체 메소드 호출하여 객체 실행

: 인터페이스로 매개하면 개발 코드 수정 없이 -> 다양한 객체들로 변경하며 사용 가능

**[인터페이스 선언] : interface 키워드**

public **interface** 인터페이스이름 {

}

: 인터페이스 구성멤버: 상수필드와 추상메소드

     **<상수 필드 선언>**

**[public static final]** 타입 상수이름 = 값;

//생략해도 컴파일 과정에서 자동으로 붙음

//인터페이스 상수는 반드시 선언과 동시에 초기값 지정

     **<추상 메소드 선언>**

**[public abstract]** 리턴타입 메소드이름(매개변수); //선언부만 작성

//생략해도 컴파일 과정에서 자동으로 붙음

: 추상 메소드 부분 = 객체 사용 방법 기술된 부분

: 개발 코드가 인터페이스의 추상 메소드 호출 시

    →인터페이스 타입 변수에 대입된 구현 객체 속 실행 메소드 호출 실행

**[인터페이스 구현]**

    **<구현 클래스>**

: 내부에 인터페이스 추상 메소드 재정의한 실체 메소드를 가지는 클래스

: 구현 클래스로부터 객체 생성하여 인터페이스 타입 변수에 연결하면

                                                               인터페이스로 해당 객체 사용 가능한 상태가 된다.

```java
**public** class 구현클래스이름 **implements** 인터페이스이름 {

//실체 메소드 재정의

}
```

: 구현 클래스의 실체 메소드 작성 시. public 보다 낮은 접근 제한 X

: 인터페이스의 모든 추상메소드가 기본적으로 public 접근 제한 가지기 때문

    **<다중 인터페이스 구현 클래스>**

: 다수의 인터페이스가 구현 객체의 메소드 호출하기 위해서는

                                  해당 구현 클래스에서 다수의 인터페이스를 모두 구현해야 한다.

: 다중 인터페이스 구현 = 구현클래스 내부에 구현할 모든 인터페이스의 실체 메소드 작성

```java
public class 구현클래스이름 **implements** 인터페이스1, 2, 3 {

//각 인터페이스 추상 메소드에 대한 실체 메소드 재정의

}
```

**[인터페이스 사용]**

: 구현 객체가 인터페이스 변수에 대입되면 인터페이스로 해당 객체 사용O

: 인터페이스로 구현 객체 사용하는 방법

    **<개발 코드 작성 시>**

1) 필드 타입 -> 인터페이스 타입

: 해당 필드에 원하는 구현 객체 대입

2) 생성자의 매개변수타입 -> 인터페이스 타입

: new연산자로 객체 생성하여 생성자 호출 시, 매개값으로 원하는 구현 객체 대입

3) 로컬 변수 타입 -> 인터페이스 타입 사용

: 해당 변수 선언된 블록 내부에서 변수에 원하는 구현 객체 대입

4) 메소드의 매개변수타입 -> 인터페이스 타입

: 메소드 호출 시, 원하는 구현 객체를 매개값으로 대입

   → 각 변수에 대입된 구현 객체는 각 객체 내부의 재정의된 실체 메소드를 실행

   → 인터페이스 타입 변수에 어떤 구현 객체 대입되느냐에 따라 해당 객체 실체 메소드 실행됨

## **08-2. 타입변환과 다형성**

**[인터페이스의 다형성]**

: 인터페이스 타입 변수에 구현 객체 대입하여, 구현 객체 교체함으로서 프로그램 실행 결과 다양해진다.

**[인터페이스의 자동 타입 변환]**

: 인터페이스 타입으로 선언된 자리에 다양한 구현 객체를 대입하면,

구현 객체가 인터페이스 타입으로 자동 타입 변환된다.

: 인터페이스 구현 클래스를 상속받은 자식 클래스 또한, 인터페이스 타입으로 자동타입변환O

**[필드의 다형성]**

: 필드 타입으로 인터페이스 타입을 선언 시, 필드값으로 다양한 구현 객체 올 수 O

; 구현 객체들은 공통적으로 해당 인터페이스를 구현한 객체들이기 때문에 모두 해당 인터페이스의 메소드를 재정의해서 가지고 있다.

: 구현 객체 = 인터페이스 타입으로 동일하게 사용할 수 있는 교체 가능한 객체O

: 교체된 구현 객체 속 실체 메소드가 호출된다.

**[매개변수의 다형성]**

: 매개변수를 인터페이스 타입으로 선언 시, 매개값으로 다양한 구현 객체 대입하여 호출 O

: 인터페이스 타입의 매개변수로 구현 객체가 매개값으로 대입되면서 자동 타입 변환됨

**[강제 타입 변환]**

: 구현 객체가 인터페이스 타입으로 자동 타입 변환되면 인터페이스에 선언된 메소드만 사용O

: 만약 구현 객체 속 선언된 자체 필드,메소드 사용해야 할 경우,  다시 구현 클래스 타입으로 변환 후 사용 가능

```java
Vehicle vehicle = new Bus();

Bus bus = (Bus) vehicle;
```

**[객체 타입 확인] : instanceof 연산자**

: 강제타입변환은 구현객체가 인터페이스 타입으로 변환된 상태에서만 가능

-인터페이스 타입으로 변환된 Bus타입 객체 속 자체 메소드를 사용해야 하는 상황

-매개값으로 들어오는 객체 = 강제타입변환 대상인 구현 객체인지 확인 필요

```java
public void Drive (Vehicle vehicle) { //매개값으로 들어와서 인터페이스타입으로 자동변환된 객체가 
	if (vehicle instanceof Bus) {  //Bus타입 객체인지 확인
	   Bus bus = (Bus) vehicle; //강제타입변환
	   bus.chechFare(); // Bus객체의 자체 메소드 호출
	 }
```

**[인터페이스 상속]**

: 인터페이스도 다른 인터페이스 상속할 수 있다. 다중 상속도 허용

```java
public **interface** 하위인터페이스 **extends** 상위인터1, 상위2, 상위3 { ... }
```

:하위인터페이스 구현 클래스는 내부에

      하위인터페이스 + 하위 인터페이스가 상속받은 상위 인터페이스의

모든 추상 메소드에 대한 실체 메소드를 작성해야 함

: 하위인터페이스를 구현한 구현 클래스로부터 객체 생성 -> 인터페이스 타입 변수에 대입

  → 해당 인터페이스 타입으로 자동 타입 변환된다.

**하위인터페이스 변수 = new 구현클래스();**

**상위1인터페이스 변수 = new 구현클래스();**

**상위2인터페이스 변수 = new 구현클래스();**

: 구현 객체가 하위 인터페이스로 타입 변환되면, (상,하위 인터페이스)모든 메소드 사용 가능

: 구현 객체가 상위 인터페이스로 타입 변환되면, 상위 인터페이스에 선언된 메소드만 사용O