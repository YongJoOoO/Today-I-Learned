# **ch02. 변수와 타입**

### **02-1. 변수**

**[변수]**
- 변수 : 값을 저장할 수 있는 메모리의 특정 공간에 붙이는 이름
            -> 선언하면 공간을 갖고, 값을 저장하면 해당 변수 공간에 실질 값 저장된다.

**[변수 선언]**
: 메모리 해당 공간에 어떤 타입의 데이터를 저장할 것인지, 저장 공간의 타입과 이름을 선언

**[변수 값 저장]**
: 대입 연산자를 사용해서, 앞서 선언으로 할당해놓은 메모리 공간 변수에 값을 저장.
: 자바는 변수 값이 저장되지 않은 상태에서는 변수 생성이 안 된다.
: 최초로 변수에 값이 저장되는 ‘변수 초기화’ 이후, 실질적으로 변수가 생성된다.

**[변수 사용]**
: 변수에 저장된 변수값을 이용해서 출력문이나 연산식을 수행하는 것.
: 변수는 또 다른 변수에 대입하여 ‘값 복사’할 수 있다.

**[변수 사용 범위]**
로컬 변수(지역변수) : 메소드 블록 내에서 선언된 변수
: 메소드 실행이 끝나면 메모리 자동 반환

**<선언 위치에 따른 사용 범위>**
-메소드 블록 첫 머리 선언

       : 해당 메소드 블록 전체에서 사용 가능
-메소드 내부의 특정 블록 내부에서 선언

       : 해당 블록에서만 사용 가능

---

### **02-2. 기본 타입**

**[기본 타입]**

: 정수 타입 = byte, char, short, int, long

: 실수 타입 = float, double

: 논리 타입 = boolean

**<리터럴>** : 변수 타입에 맞는 **데이터값**

**[정수 타입]**

: char타입은 문자 저장 타입으로, 유니코드값만 저장하므로 음수 X

: long타입은 수치 큰 데이터 프로그램에서 주로 사용.

: 각 타입 별 허용 범위 안에서만 값 저장 가능

: 기본적으로 컴파일러는 정수 리터럴을 int 타입으로 간주

<long타입> : long타입으로 정수 리터럴 원하면, 정수+L 붙여줘야 long타입으로 정상 인식O

<char 타입> : 문자 리터럴은 작은 따옴표로 감싸서 ‘A’ -> char타입에 저장

<string 타입> : 문자열 리터럴은 큰 따옴표로 감싸서 “A” -> string타입에 저장

**[이스케이프 제어 문자] : 문자열 내부에서 출력 제어 기능**

\t : 탭  \n : 개행 \r ; 캐리지 리턴

\**\** : \출력

\**“** : (”) 출력 (문자 식별 기호가 아닌 데이터로서 사용시)

\**‘** : (’) 출력

**\u**16진수 : 16진수 유니코드에 해당하는 문자 출력

**[실수 타입]**

: 소수점 있는 실수 리터럴 저장 타입

: float 타입 = 소수점 이하 7자리

: double 타입 = 소수점 이하 15자리 (多 사용)

: 자바는 실수 리터럴을 기본적으로 double 타입으로 해석

<float 타입> : float타입으로 실수 리터럴 원하면 실수+F 붙여줘야 float타입으로 정상 인식O

**[논리 타입]**

: true, false 2가지 값만 저장하는 타입

: boolean타입 변수는 주로 2가지 값에 따라 조건문,제어문의 실행 흐름 변경하는 데 사용O

          ex) if문 안에 boolean타입 변수 넣어주면, 해당 변수의 값이 참일 때만 실행

```java
		boolean stop = true;

		if(stop) { //참이면 실행
			System.out.println("중지합니다."); 
		}else { //거짓이면 실행
			System.out.println("실행합니다.");
		}
```

---

### **02-3. 타입 변환**

<aside>
💡 : 최초 선언된 변수 타입을, 다른 타입의 변수에 저장할 때 타입변환 발생

</aside>

**<허용범위 크기 순>** 

byte < char < short < int || < float < double

✅**[자동 타입 변환]**

: 허용 범위 작은 타입 -> 허용 범위 큰 타입으로 저장 시 발생

    **<char 예외>** : 음수 값 갖지 못하므로 char보다 작은 타입이 char타입에 저장되어도 변환X

✅**[강제 타입 변환]**

: 허용 큰 범위 타입 -> 허용 작은 범위 타입으로 강제 형 변환

: 큰 타입을 작은 타입 크기로 쪼개서 강제 저장

: 캐스팅 연산자( ) 사용

---

**[정수 연산식 | 자동 타입 변환]**

     산술 연산식에서 피연산자로 정수 타입이 사용되면 연산 수행 시 자동 타입 변환된다.

**(1) 피연산자에 byte, short, int 타입 정수 연산식**

- 연산 수행 시 피연산자들은 int타입으로 자동 변환되므로, 연산 결과는 int타입 변수에 저장
- 특별한 이유 없으면 정수 연산식에서는 int타입 피연산자 사용하면 된다.

**(2) 피연산자에 long타입 포함된 정수 연산식**

- 연산 수행 시 나머지 피연산자들이 long타입으로 변환되어 연산 수행된다.
- 연산 결과는 long타입 변수에 저장

**[실수 연산식 | 자동 타입 변환]**

    산술 연산식에서 피연산자로 실수 타입이 오는 경우,

**(1)피연산자 동일 타입으로 연산 시 -> 해당 타입으로 연산 수행**

**(2)피연산자 다른 타입으로 연산 시 -> 큰 double타입으로 자동 타입변환되어 연산수행**

→이 경우 연산 결과는 double타입변수에 저장

**[정수끼리의 연산 결과로 실수값 갖기]**

→ 기본적으로 정수끼리의 연산 결과는 정수값.

- 연산식에서 피연산자 하나라도 강제 형변환 처리-> 연산 수행 결과는 실수 결과값 가짐

**[문자열 결합 연산 | 자동 타입 변환]**

: + 연산식에서 피연산자 하나라도 “문자열” 올 경우,

         나머지 피연산자들도 문자열로 자동 타입 변환되어 연산 수행된다.

: + 연산은 앞에서부터 순차적으로 수행됨

```java
String str = 1 + 2 + “3”; -> 3 + “3” -> “33”
```

---

**[문자열 -> 기본타입 // 강제 타입 변환]**

: 자바에서 기본 제공하는 API의 클래스 내부 메소드 사용

```java
int value = Integer.parseInt(“문자열”);

double value = Double.parseDouble(“문자열”);
```

    **<숫자 형식 예외발생>**

: 숫자 타입으로 변환할 대상 문자열에 숫자 외의 문자 포함된 경우 에러

```java
String str = “ 123AAB”;

int value = Integer.parseInt(str); // NumberFormatException 발생
```

**[기본 타입 -> 문자열 변환]**

**(1) String.valueOf() 메소드 이용**

```java
String str = String.valueOf(3.0); -> 문자열 “3.0”으로 변환됨
```

**(2) “” 빈 문자열과의 결합 연산 수행**

```java
String str = “” + 3.0 ; -> 문자열 “3.0” 으로 변환됨
```

---

### **02-4. 변수와 시스템 입출력**

```java
System.out. : 시스템의 표준 출력장치(모니터)로 출력

println(); printf(); print(); 메소드

System.in : 시스템의 표준 입력장치(키보드)로 입력

read(); 메소드
```

**[모니터로 변수값 출력]**

**System.out : 시스템의 출력장치 out**

                    **→ 제공 메소드 : println();, print(); printf();**

- println(내용); // 내용 출력 후 개행
- print(내용); // 내용 출력
- printf(“형식문자열”, 값1); // 형식 문자열대로 출력

**<printf();의 형식문자열>**

**% + [$값순번] [공백처리] [전체 자릿수] [소수 자릿수] + 변환문자(d, f, s)**

**[키보드에서 입력된 내용을 변수에 저장]**

System.in : 시스템의 입력 장치 in -> **read(); 메소드** 사용

**System.in.read();** 는 키보드 입력값을 (숫자로 된) 키코드 값으로 읽어온다.

**<구조>**

```java
public static void main(String[] args) **throws Exception { //예외처리구문**

		**int** keyCode = System.in.read();

}
```

      :숫자로 된 키코드 “하나씩” 읽어 **int 변수에 저장 (키코드=숫자)**

:read(); 실행되면 이클립스 콘솔뷰는 enter키 입력될 때까지 대기 상태

:Enter키에 대한 키코드도 읽음( 13 + 10 ) 키코드 2개임

:문자 하나 입력하면, 구성된 키코드는 총 3개이므로, 한 문자에 대한 키코드 전부 읽으려면 read(); 3번 호출함

: 반복문 사용하면 계속 read() 호출하므로 입력된 값의 키코드 전부를 읽어온다.

:입력된 키코드 전부 읽고나면 다시 Enter키 입력을 대기

**<예외처리코드> throws Exception : 모니터에 예외 내용 출력**

  → 단점 : 키코드 하나씩 읽기 때문에, 2개 이상의 키 조합된 한글은 읽지 못함

                                즉, 키보드로 입력된 내용을 통문자열로 읽지 못한다.

**[Scanner클래스] : 키보드로 입력된 내용을 통문자열로 읽음**

**<구조>**

```java
import java,util.Scanner;

Scanner scanner = new scanner(System.in);

String inputData = scanner.nextLine();
```

**[저장 타입 비교]**

```java
int @ = System.in.read(); // 숫자로 된 키코드로 읽어서 int타입에 저장

String @ = scanner.nextLine(); //문자열 읽어서 String타입에 저장
```

**[값 비교]**

**(1) 기본 타입 값의 비교 : == 사용**

**(2) 문자열(String) 비교 : equals(); 메소드 사용**

```java
boolean result = inputData.equls(“q”);
```

---