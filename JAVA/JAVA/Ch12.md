# **ch12. 스레드**

## **12-1. 멀티 스레드**

**[프로세스]**

: 운영체제에서 실행 중인 하나의 애플리케이션

: 운영체제로부터 메모리 할당받아 애플리케이션 실행

- 단일 프로세스 : 하나의 애플리케이션 내부, 단 하나의 프로세스
- 멀티 프로세스 : 하나의 애플리케이션 내부, 多 프로세스

**[스레드]**

: 하나의 작업 실행에 필요한 하나의 코드 실행 흐름

: 멀티 스레드 생성 -> 병렬로 실행 -> 멀티 태스킹 수행 O

- 싱글 스레드 ; 하나의 프로세스 내부, 단 하나의 메인 스레드
- 멀티 스레드 : 하나의 프로세스 내부, 메인 스레드 1개 + 여러 개의 작업 스레드 들

**[멀티 프로세스 VS 멀티 스레드 비교]**

**🟨멀티 프로세스 : 독립적 실행**

: 각 프로세스가 운영체제에서 자신의 메모리를 할당받아 실행하므로

각 프로세스는 서로 독립적이다. 하나의 프로세스의 오류가 또 다른 프로세스에 영향 X

🟨**멀티 스레드 : 종속적 실행**

: 하나의 프로세스 내부에 멀티 스레드가 생성되므로,

하나의 스레드 예외발생 시 -> 다른 스레드들 영향 미침

**[메인 스레드] : 1개**

: main() 메소드 첫 코드 ~ 마지막 코드까지의 작업 코드 실행 단위

: 자바의 모든 애플리케이션은 메인 스레드가 main() 메소드 실행하면서 시작됨

**[작업 스레드] : 多 개**

: 메인 스레드 외에, 메인 스레드와 병렬로 동시 실행되어야 할 작업들을 분류하고,

각 작업별로 작업 스레드 생성하여 동시 작업 수행 가능케 함

: 작업 스레드들을 여러 개 만들어 병렬로 코드 실행시키면, 멀티 스레드 생성되어 멀티태스킹 가능

## [1] 작업 스레드의 객체 생성

구현 클래스, 자식 클래스는 각각 내부의 run() 메소드 재정의해서 생성

   → 스레드.**start() 메소드**로 작업 스레드 + 메인 스레드 동시 실행됨

### 1) **Thread 클래스로부터** 작업 스레드 **직접** 생성

: Thread 타입 <- Thread 객체 생성자 (매개값)에 구현 객체 **대입**

```java
Thread thread = new Tread ( 구현 객체 ) ;
```

**(1). 별도의 구현 클래스 생성 후, 구현 객체 생성 -> 대입**

```java
class Task **implements Runnable** { ... } //매개값 줄 용도로 객체 생성

Thread thread = new Thread(**Task**); //작업 스레드 객체 생성
```

**(2). 익명 구현 객체 생성 후 -> 즉시 Thread 타입에 대입 연결**

```java
Thread thread = new Thread **( new Runnable() { ... }** **);**
```

### **2) Thread 자식 클래스로부터 작업 스레드 생성**

: Thread thread 타입 <- 자식 객체 생성자 **연결**

```java
Thread thread 타입 = new 자식 객체 생성자() ;
```

**(1). 별도의 자식 클래스 생성 후, 자식 객체 생성** 

```java
class Task **extends Thread** { ... }

Thread thread = new **Task();**
```

**OR 이미 자체로 Tread 상속받은 자식 클래스라 꼭 Tread타입 연결없이도 객체 생성해도 스레드 객체생성O**

```java
User1 user1 = new User1();
```

**(2). 익명 자식 객체 생성 후, 즉시 Thread 타입에 대입 연결**

```java
Thread thread = new Thread () **{ ... };**
```

## **[2] 스레드의 이름**

메인 스레드 이름 : ‘main’

작업 스레드 이름 : ‘Thread-n’

스레드 이름 **재설정** : thread.**setName(“이름”);**

스레드 이름 **읽기** : thread.**getName();**

현재 **스레드 객체의 참조 얻기**

Thread thread = Thread.**currentThread();**

: setName(), getName() 은 Thread 클래스의 인스턴스 메소드이므로 각각의 스레드 객체 참조가 필요하다.

## **[3] 동기화 메소드 : synchronized 키워드 + 메소드 선언**

**:** **여러 스레드 사용 중인 공유 객체 속에 동기화 메소드 정의해둘 경우,**

**어느 스레드 하나가 해당 동기화 메소드 실행 동안은 공유객체 자체 잠금 처리됨**

: 멀티 스레드 프로그램에서 스레드들이 객체 공유 작업 시 동기화 메소드 사용

: 하나의 스레드가 사용 중인 공유 객체에 다른 스레드가 접근할 수 없도록 하기 위함

**임계영역** : 멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역

: 임계영역 지정 위해 동기화 메소드 사용

하나의 스레드가 동기화 메소드 실행 시, 해당 공유 객체 자체 즉시 잠금 처리
--> 동기화 메소드 종료 시 잠금 해제되어 다른 스레드 접근 가능해짐

동기화 메소드 여러 개일 경우  한 스레드가 동기화 메소드 하나 실행 중 -> 다른 스레드는 해당 동기화 메소드 X
-> 다른 스레드가 다른 동기화 메소드도 실행 X
-> But> 다른 메소드가 다른 일반 메소드는 실행 가능 O

```java
public synchronized void setMemory(int memory) { 
	... 임계영역 ; // 단 하나의 스레드만 실행 가능한 여역
	}
```

## **12-2. 스레드 제어**

**[스레드 상태]**

: 스레드는 실행 대기 상태와 실행 상태 번갈아가면서 run() 메소드 조금씩 실행함

: 일시 정지 상태에서는 바로 실행 상태로 돌아갈 수 없고 -> 실행 대기 상태로 감

- 실행 대기 상태 : start() 호출된 스레드는 일단 실행 대기 상태
- 실행 상태

:운영체제가 선택한 스레드

- run() 메소드 모두 실행되기 전 // 실행 상태, 실행 대기 상태 번갈아 가며 run() 조금씩 실행
- 일시 정지 상태 // Tread.sleep() 호출 시 일정 시간 정지 상태 -> 실행 대기 상태
- 종료 상태

**1) run() 메소드 모두 실행되어 종료되면 // 일반 정상 종료 상태**

**2) 안전하게 중간 종료**

➡️(1) stop 플래그 이용 : setStop() 메소드로 stop T값 변경하여 정상 종료

➡️(2) interrupt() 이용 : 일시 정지 상태에서만 효과 O (예외처리catch블록이동)

**[스레드 상태 제어]**

: 실행 중인 스레드의 상태를 변경하는 것

**< 스레드 상태 제어 메소드 종류>**

```java
sleep( ) ; // 주어진 시간동안 일시 정지 상태. 시간 지나면 자동 실행 대기 상태

interrupt() ; // 일시정지상태 스레드에 한해 -> 예외 발생시켜 -> catch블록 이동 
		-> while문 탈출하여 정상 종료 
stop() ; // 비정상 종료 사용 X
```

**< 스레드의 안전한 종료 >**

**1) run() 메소드 모두 실행되어 종료되면 // 일반 정상 종료 상태**

**2) 안전하게 중간 종료**

➡️(1) stop 플래그 이용 : setStop() 메소드로 stop T값 변경하여 정상 종료

➡️(2) interrupt() 이용 : 일시 정지 상태에서만 효과 O (예외처리catch블록이동)

- **1) Thread.sleep(1); // 일부러 짧게 일시정지 상태 만들어 interrupt() 호출**
- **2) 호출 여부 확인 메소드 -> if문 이용 -> break; 정상 탈출**
    
    

```java
// Thread.interrupted() : 정적 메소드, 현재 스레드 interrupted 확인

// Thread.isInterrupted() ; 인스턴스 메소드. 현재 스레드 intterrupted 확인
```

**[데몬 스레드]**

: 주 스레드의 작업을 돕는 보조역할 스레드

: 주 스레드 종료되면 데몬 스레드 자동 강제 종료

: start() 메소드 호출 전 setDaemon(true); 호출해야 에러X

: 어떤 스레드를 데몬으로 만들 스레드 객체 생성 후, setDaemon(true); 호출하면

  →  해당 스레드가 데몬 스레드로 지정됨