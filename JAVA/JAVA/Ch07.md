# **ch07. 상속**

## **07-1. 상속**

**[클래스 상속]**

: 자식이 부모 클래스를 선택해서 부모 클래스의 필드와 메소드를 상속받는다.

|  class 자식클래스 extends 부모클래스 {
    
} |
| --- |

**[상속 특징]**

 1) 다중 상속 불가능. extends 뒤에는 오직 하나의 부모클래스만 온다

 2) 부모 클래스의 private 필드, 메소드 : 상속 제외

 3) 다른 패키지에 존재하는 부모 클래스의 default 필드.메소드 : 상속 제외

**[부모 생성자 호출]**

: 상속 이루어진 자식 클래스에서 자식 객체 생성 시 

                              내부적으로 부모 객체가 먼저 생성되고, 자식 객체가 생성된다.

: 생성자를 호출해야 객체가 생성된다.

: 자식 객체 생성을 선언하면

            부모 객체 생성을 먼저 하기 위해 자식 생성자의 맨 첫줄에서 부모 생성자 호출된다.

     **<명시적으로 생성자 호출X ->**

: 컴파일러가 자식 생성자 첫줄에 super();를 자동 추가해서 사용

: 단, 이 경우에는 부모 클래스에 기본 생성자가 존재해야 컴파일 에러 안남.

     **<명시적으로 생성자 호출O>**

자식 생성자 (매개변수선언...) {

**super(매개값);**  //첫 줄에서 부모 생성자 직접 명시적으로 호출

}

: super(매개값); 은 매개값의 타입과 일치하는 부모 생성자를 호출한다.

**[메소드 재정의] : 오버라이딩 (Overriding)**

: 부모 클래스로부터 상속된 일부 메소드를 **자식 클래스에서 재정의**하여 사용

: 자식 클래스에서 재정의되면, 해당 부모 객체의 메소드는 숨겨지고,

                           메소드 호출 시, -> 자식 객체에서 재정의된 자식 메소드가 호출됨

```java
  @Override
	double areaCircle(double r) {
		  System.out.println("Computer 객체의 areaCircle()");
		return Math.PI * r * r;
}
```

 ****

    **<메소드 재정의 방법>**

- 부모 메소드와 동일한 시그니처(리턴타입, 메소드이름, 매개변수)
- 부모 메소드보다 더 강한 접근제한 불가
- 새로운 예외를 throws 불가

     **<이클립스 메소드 재정의 자동 추가>**

**ctrl + space바** -> 재정의 대상 메소드 이름 선택 -> 자동 재정의 코드 생성됨

     **<재정의 후, 기존 부모 메소드 호출>**

: **자식 클래스 내부에서 재정의 이전의 부모 메소드 호출해야 할 경우**

                                                  명시적으로 super키워드 붙여서 부모 메소드 호출 가능

                    cf. 그냥 메소드 호출시, 재정의된 메소드 호출되기 때문

                     **super.**부모메소드(); 

```java
  @Override
	public void fly() {
		if(flyMode == SUPERSONIC) {
			System.out.println("초음속 비행");
		}else {
			super.fly();
		}
//이후 실행 클래스에서 fly(); 호출시, 재정의 조건에 맞춰 메소드가 선택적으로 호출됨
```

**[final 클래스와 final 메소드]**

final 키워드 : 해당 선언이 최종 상태이고 이후 수정 불가함

final 필드 : 초기값 설정 후, 더 이상 값 변경 불가능

   **<final 클래스>**

: 이 클래스는 최종적인 클래스이므로 상속 불가능한 클래스

: final 클래스는 자식 클래스 만들 수 없다.

|  public final class 클래스 { ... } |
| --- |

   **<final 메소드>**

: 부모 클래스의 final 메소드는 자식 클래스에서 재정의 불가능

: 이 메소드는 최종적인 메소드이므로 이후 재정의 불가능한 메소드

| public final 리턴타입 메소드 ( ) { ... } |
| --- |

## **07-2. 타입변환과 다형성**

[클래스 타입변환]

: 다른 클래스 타입으로 객체(or 객체를 참조하는 변수) 대입하면, 해당 객체는 그 타입으로 변환된다.

: 자동 타입 변환 성질 이용하면, 부모 타입 선언된 자리에 모든 자식 객체가 올 수 O

: (자식 -> 부모) 타입변환 이후, 부모타입변수로는

                부모 클래스 내부의 필드, 메소드 접근O+ 재정의한 메소드만 호출 가능.

: 자동 타입변환 이후, 자식만의 필드, 메소드 접근해야 할 경우, 다시 (강제 타입 변환)

**[다형성]**

: 부모 타입에 여러 자식 객체를 대입가능하게 만드는 (자동타입변환) 성질 이용해서

다양한 객체를 이용해 다양한 실행 결과가 나오도록 만드는 성질

: (메소드 재정의 + 타입변환)을 이용해서 다형성 구현된다.

**[클래스의 자동 타입 변환]**

: 클래스의 변환은 오직 상속 관계에 있는 클래스 사이에서만 발생

: 자동 타입 변환의 매커니즘은,

       부모의 기능 상속받은 자식 객체도 부모와 동일 취급해도 된다는 것O

: 자식 클래스로부터 자식 객체 생성 후,

       이 객체를 부모타입변수에 대입하면 자동 타입 변환이 발생.

| - 즉, 자식 객체 생성 후 반환된 자식 객체 주소 번지를 다시 부모타입 변수에 대입시켜서 부모타입변수가 자식 객체를 참조하는 상태가 된다.
- 다만, 이 경우 자식 객체 참조하는 변수타입이 부모의 것으로 변환되기 때문에, 부모타입 변수로는 부모객체의 타입, 메소드에만 접근 가능. = 부모 객체처럼 취급 O
              = 부모타입변수 연결된 자식 객체 = 부모객체처럼 취급 O |
| --- |

**◾상속 : 부모 객체의 필드, 메소드도 접근 O)**

**◾자동 타입 변환 : 부모 객체의 필드, 메소드만 접근 O)**

**[필드의 다형성]**

: 필드타입을 부모타입으로 선언해두면, 해당 필드값에 다양한 자식 객체들이 올 수 있다.

: 객체를 다른 성능 좋은 객체로 교체 가능하게 만듬

: 다양하게 교체되는 자식 객체들이 내부에 재정의한 메소드를 가지고 있을 경우,

             해당 프로그램은 객체 교체 마다, 다양한 실행 결과 구현이 가능해진다. (=다형성)

**: 교체 전 -> 부모 타입의 메소드 호출**

**: 교체 후 -> 자식이 재정의한 메소드로 호출**

: 자동타입변환을 이용해서, 부모 타입으로 정의된 필드에 다양한 자식 객체들로 교체하며

다양한 재정의 메소드를 구현 - > 다양한 실행결과 만드는 것 (필드의 다형성)

: 부모타입에 자식 객체 대입 시 -> 자동타입변환되어 부모타입이 됨

**[매개변수의 다형성]**

: 메소드의 매개변수를 부모타입으로 선언해두면 해당 매개값 자리에 다양한 자식 객체들이 올 수 있다.

: 자식 객체는 부모타입으로 대입 시, 부모타입으로 자동 타입변환됨

**[강제 타입 변환]**

: 자식타입 객체를 부모타입으로 자동 타입 변환된 상태에서 해당 객체를 다시 자식 타입으로 변환할 때 사용

: 자식의 자체 필드, 메소드를 꼭 사용해야 할 경우,

               강제타입변환 하여 다시 자식 타입으로 변환 후에 자식 필드, 메소드 사용

**자동 : Parent parent = new Child();**

**강제 : Child child = (Child) parent;**

   // 부모타입변수를 자식타입으로 (강제 형 변환)시켜서 자식타입에 대입

기존 부모타입변수가 참조하고 있던 자식객체를 다시 자식 타입에 대입시킴

부모타입이던 자식 객체는 다시 자식 타입되어 자식타입변수로

자식 객체의 자체 메소드,필드 이용 가능

**A a = new B();**

**B b = (B) a;**

**[객체 타입 확인] ; instanceof 연산자**

: 주로 강제 타입 변환 전에 변환 가능 여부를 확인하기 위해 사용

: 부모 변수가 참조하는 객체가 자식 객체인지 확인

   → 자식 객체 참조 중 = 자동 타입 변환된 상태 O

```java
boolean result = (객체 or 참조타입변수) instanceof (타입);

	public void method(Parent parent) {
	if (parent instanceof Child ){ //부모타입 매개변수로 대입된 객체가 자식 객체인가?  
		 Child child = (Child) parent; //대입된 객체를 다시 원래 자식 객체로 타입변환
		}
	   }
```

## **07-3. 추상 클래스**

**[추상 클래스]**

: 실체 클래스들의 공통 필드, 메소드 추출하여 따로 선언

**[실체 클래스]**

: 추상 클래스의 모든 특성을 물려받은 후, 추가 특성 가지는 클래스

: 객체 직접 생성할 수 있는 클래스

**[추상 클래스의 용도]**

1) 실체 클래스들의 공통된 필드,메소드 **이름 통일 목적**

: 공통된 필드,메소드를 상속받음으로서 자동 이름 통일

2) 실체 클래스 작성 시 **시간절약**

: 공통된 필드,메소드는 상속받고, 추가적인 특성만 선언하면 됨

**[추상 클래스 선언] abstract 키워드**

```java
public abstract class 클래스이름 { 
	  //필드
	  //생성자
	  //메소드 
	}
```

: **abstract 키워드** 붙이면 new연산자 이용해서 직접 객체 생성 불가능

: 오직 상속을 통해 자식 클래스만 만들 수 있다.

: 다만, 추상 클래스도 생성자 반드시 있어야 하는데,

이는 자식 클래스에서 객체 생성 시,

부모 생성자 super(); 호출하여, 부모 객체 생성 후 자식 객체를 생성하기 때문

**[추상 메소드와 재정의]**

: 하위 실체 클래스들이 공통되게 메소드를 가지고 있으나,

            실체 클래스마다 메소드의 실행 내용이 달라야 할 경우 -> 추상 메소드 선언

: 추상 메소드 = 메소드의 선언부만 O , 실행부 X

                      **abstract** 리턴타입 메소드이름(매개변수) ;

: 추상 클래스에서 추상 메소드가 선언되면

   자식 클래스는 반드시 추상 메소드를 재정의해서 실행 내용을 작성해야 한다. (컴파일 에러됨)

```java
		//sound() 호출 방식 1

		Dog dog = new Dog();
		Cat cat = new Cat();
		dog.sound();
		cat.sound();
		
		//sound() 호출 방식 2 

		Animal animal = new Dog();
		animal.sound();
		Animal animal = new Cat();
		animal.sound();
		
		//sound() 호출 방식 3

		animalSound(new Dog());
		animalSound(new Cat());
		
		public static void animalSound(Animal animal) {
			animal.sound();
		}
```