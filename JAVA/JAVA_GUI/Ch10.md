# 🟩 Ch10. 사용자 이벤트 처리

# **ch10. 사용자 이벤트 처리**

# **10-1. 이벤트 구동 프로그래밍**

# **[이벤트 구동 프로그래밍]**

- 이벤트 발생 시, 연결된 컴포넌트에 대해 이벤트 리스너 토대로 적절 처리 프로그래밍 방식
- 이벤트에 의하여 실행 순서가 결정되는 방식
- 이벤트 발생 → 이벤트 객체 생성 -> 컴포넌트에 등록된 이벤트 리스너가 이벤트 처리

# [이벤트 리스너 작성 과정]

## (1) 리스너 인터페이스를 구현한 ‘이벤트 리스너 클래스 작성’

```
class 이벤트리스너 implement 리스너 인터페이스 { ... }
```

## (2) 컴포넌트에 이벤트 리스너 객체 등록

```
컴포넌트 . add____Lister(new 리스너 객체());
```

# [이벤트 객체]

- 이벤트 객체: 발생된 이벤트에 대한 모든 정보를 리스너로 전달
- 이벤트 객체 내부 getSource() 메소드 : 이벤트 발생한 이벤트 소스를 반환하는 메소드

                           : Object타입으로 반환하므로 필요한 타입으로 형변환시킨 뒤 사용 O

# 10-2. 다양한 이벤트 처리 방법

- **리스너 클래스 ‘작성 위치’에 따라 이벤트 처리 방법 5가지 존재**

## 1) 리스너를 독립된 클래스로 작성

단, 컴포넌트 사용할 때, 컴포넌트가 외부 클래스의 private 멤버이면 접근이 어려움

## 2) 리스너를 중첩된 클래스로 작성

- 컴포넌트 포함된 프레임 클래스가 ‘바깥 클래스’가 되고, 이벤트 리스너 클래스가 ‘중첩 멤버 클래스’가 되면,  중첩된 클래스 안에서 바깥 클래스 멤버 접근 용이해짐 ((-> 1)의 문제점 보완)

## 3) 프레임 클래스 혼자 상속 동시에 구현

- 프레임 클래스 안에서 메소드 재정의도 이뤄짐

```
 class 프레임 extends JFrame implements 리스너인터페이스 {... }
```

## 4) 리스너를 익명 클래스로 등록

- 컴포넌트 등록 메소드 매개변수로 리스너 익명 객체 즉시 대입시킴

## 5) 리스너의 메소드 자체를 람다식으로 등록

- 람다식 : 매개변수로 함수 전달 시, 함수를 객체로 만들어 매개변수에 전달됨

# **10-3. 스윙 컴포넌트의 이벤트**

# **[스윙 컴포넌트 이벤트]**

## 1) 저수준 이벤트 : 모든 컴포넌트에서 발생

ex) Component, Focus, Container, MouseWheel, Window, Key, Mouse, MouseMotion

## 2) 의미적 이벤트 : 일부 컴포넌트에서만 발생

- 이식성이 좋고 내부에 추상 메소드를 1개만 갖고 있기 때문에 가능하면 의미적 이벤트 처리
- 각 컴포넌트 별로 발생할 수 있는 이벤트 종류가 달라짐

               ex) Action, Caret, Change, Document, Item, ListSelection

# 10-4. 액션 이벤트 (Action) : 의미적 이벤트 中

- 하나의 이벤트가 여러 개의 컴포넌트에 등록 O
- getSourse() 메소드 호출해서 이벤트 발생한 컴포넌트 소스 얻거나
- getActionCommand() 메소드 호출해서 버튼 텍스트 얻어 이벤트 소스를 구분 리스너 메소드 작성

# [액션 이벤트 발생]

- 사용자가 버튼 클릭하는 경우 (컴포넌트 : 버튼)
- 사용자가 메뉴 항목을 선택하는 경우 (컴포넌트 : 버튼(메뉴))
- 사용자가 텍스트 필드에서 엔터키 누르는 경우 (컴포넌트 : 텍스트필드)
- 패널의 setBackground() 메소드 : 패널 배경색 변경

# 10-5. 키 이벤트 : 저수준 이벤트 中

- 키 이벤트 : 사용자가 키보드를 이용하여 입력하는 경우 발생
- 사용자가 키보드 키를 누르면 -> 키의 문자 + 키 눌림 이벤트 동시에 보내진다
- 키 이벤트 발생하려면 컴포넌트가 반드시 ‘키보드 포커스’ 가지고 있어야 함

              → requestFoucus() 메소드로 키보드 포커스 얻음

## <키 이벤트의 형태>

1) KeyTyped 이벤트 : 입력된 유니코드 문자 전송

2) KeyPressed 이벤트 : 사용자가 키 누르면 이벤트 발생

3) KeyRelesed 이벤트 : 사용자가 키에서 손 떼면 이벤트 발생

# [KeyListener 인터페이스 속 추상 메소드]

KeyTyped(e) : 사용자 글자 입력 시 호출

KeyPressed(e) : 사용자 키 누르는 경우 호출

KeyRelesed(e) : 사용자 키 떼는 경우 호출

# 10-6. Mouse 이벤트, MouseMotion 이벤트

## ( 저수준 이벤트 中)

- 마우스에 대한 이벤트 분리한 이유 : 마우스 움직임 추적하는 것이 시스템 오버헤드 증가

# [Mouse이벤트]

- 사용자 마우스 버튼 누를 때 발생

## [MouseListener 인터페이스 속 추상메소드]

mouseClicked(e) : 사용자가 컴포넌트 한 번 클릭 시 호출

mouseEntered(e) ; 마우스 커서가 컴포넌트로 들어가면 호출

mouseExited(e) : 마우스 커서가 컴포넌트에서 나가면 호출

mousePressed(e) ; 컴포넌트 위에서 눌려지면 호출

mouseRelesed(e) : 컴포넌트 위에서 뗴어지면 호출

# [MouseMotion이벤트]

- 사용자 마우스 움직일 때 발생

## [MouseMotionListener 인테페이스 속 추상메소드]

mouseDragged(e) : 마우스 드래그(클릭한 상태로 이동) 시 호출

mouseMoced(e) : 마우스 클릭X 이동 시 호출

- getX(), getY() 메소드 : 마우스 클릭된 위치 알려줌
- getClickCount() 메소드 : 마우스 버튼 몇 번 틀릭 됐는지 알려줌
- getButton() 메소드 : 클릭된 버튼 알려줌

# 10-7. 어댑터 클래스

- 저수준 이벤트에 대해서만 존재하는 클래스
- 의미적 이벤트의 리스너 인터페이스는 추상 메소드 하나만 가지고 있기 때문에 필요 X

# [어댑터 클래스]

- 어댑터 클래스:각 리스너 인터페이스 별 모든 추상 메소드 전부를 내부에 구현해놓은 클래스
- 리스너 클래스 선언 시, 어댑터 클래스를 상속받아 원하는 메소드만 재정의할 수 O

public class 리스너클래스 extends ___Adapter { ... }

- 리스너 클래스 선언 시, 리스너 인터페이스 직접 구현하는 경우,

            인터페이스 속 사용할 메소드 외에도 모든 추상 메소드를 재정의해야만 함 (비효율)

- 리스너 클래스 선언 시, 어댑터 클래스를 상속받는 경우,

              사용할 메소드만 재정의하면 됨 (효율)

- ** **주의) 자바는 클래스 다중 상속 허용 X**

**→ 상속 동시 구현하는 방식으로 리스너 선언할 경우 Adapter클래스 상속 불가능**

**→ 해결 : Adapter 클래스 상속받은 이벤트 리스너를 ‘중첩 클래스’로 정의하여 사용**

**→ 해결 : Adapter 클래스 상속받은 익명 자식 객체로 이벤트 리스너 등록 사용**