# 🟩 Ch09. 인터페이스/람다식/패키지

# **09-1. 인터페이스 개요**

# **[인터페이스]**

- 클래스 간 상호작용의 표준 규격
- 규격 안에 합의된 추상 메소드 작성
- 인터페이스 내부에는 기본적으로 추상 메소드, 상수만 선언 가능(자동 처리됨)

# [구현 클래스]

- implement 키워드
- 인터페이스를 구현한 클래스 내부에는 반드시 인터페이스의 추상 메소드 전부를 재정의
- 이후 실행 메소드에서 구현 객체 생성하여 사용 O

## [인터페이스 VS 추상클래스] : 자체로 객체 생성 불가능

- **추상 클래스** : 하위 실체 클래스들의 공통 속성들을 내부에 선언해둔 클래스

: 내부에 (공통 속성이기만 하면) 인스턴스(일반) 필드, 메소드도 정의할 수 O

- **인터페이스** : 기본적으로 내부에 추상 메소드와 상수변수만 선언 허용함

### **<추상 클래스 사용>**

- 관련된 클래스 사이에서 공통 필드, 메소드 수 많은 경우 추상 클래스로 통일해서 사용 多
- 정적 아닌 필드, 상수 아닌 필드 선언해서 내부 작성할 때(vs 인터페이스)

### <인터페이스 사용>

- 관련 없는 클래스도 인터페이스를 구현하기 원할 때 사용 O
- 다중 상속 가능한 성질 이용할 때

# **09-2. 인터페이스의 다형성**

# **[인터페이스 다형성**]

- 인터페이스 타입 변수에 하위 구현 객체들을 대입하면,

해당 구현 객체에서 재정의해놓은 메소드들이 호출 가능해져서 실행 결과 다양해짐

- 인터페이스 타입으로 선언된 자리에 구현 객체 대입 시 자동 타입 변환되어

해당 인터페이스의 추상 메소드를 재정의한 구현 객체의 다양한 실체 메소드 내용 호출됨

                     → 실행 결과 다채로워짐

# **09-3. 인터페이스 다중 상속**

- **기존** 인터페이스에 확장된 메소드 작성 시-> 연결되어 있던 모든 구현 클래스 동작 X
- **해결**: 기존 인터페이스는 건들이지 않고, 기존 인터페이스를 상속받은 인터페이스에 추가 기능 메소드 선언해서 사용 O

→ 이 경우, 인터페이스 사용자들은 업데이트 선택권 생김

# **[인터페이스를 이용→ 클래스 다중 상속 구현]**

- 기본적으로 **인터페이스는 다중 상속 가능 O / 클래스는 다중 상속 불가능X**
- 하나의 클래스를 상속받을 수 있는 상태에서 인터페이스도 함께 상속받아 다중상속 효과O

### (1) 여러 개의 인터페이스 구현 -> 다중 상속 효과 O

```
public class 구현클래스 implement 인터페이스1, 인터페이스2, 인터페이스3 ... {}
```

### (2) 하나의 클래스 상속받고, 동시에 인터페이스도 구현 -> 다중 상속 효과 O

```
public class 클래스 extends 부모 implements 인터페이스 {}
```

# **09-4. JDK 8 버전부터 추가.**

        **인터페이스 내부에 선언 가능한 메소드 : 디폴트 메소드, 정적 메소드**

# **[디폴트 메소드]**

- **default 키워드**
- 인터페이스 내부에는 기본적으로 추상 메소드(내용 구현X)만 선언 가능했지만,

업데이트 이후) 구현 클래스에서도 따로 재정의 없이 사용 가능한 디폴트 메소드(내부구현O)를 추가

- 등장 이유: 기존 인터페이스에 추가 기능 메소드를 디폴트 메소드로 추가하여

(인터페이스 상속 없이도) 기존에 연결되어있던 구현 클래스들 코드 수정 없이 추가 메소드 사용O

# [정적 메소드]

- **static 키워드**
- 구현 클래스에서 따로 재정의없이도 바로 인터페이스.메소드()로 접근해서 호출 사용O
- 기존 인터페이스에 새로운 메소드 추가할 경우,

정적 메소드로 추가되면 기존 구현 객체들 코드 수정없이(재정의X) 해당 메소드 사용이 가능O

# **09-5. 익명 객체 (무명 객체)**

# **[익명 객체] : 이름 없는 객체**

- 클래스를 정의하는 동시에 객체를 생성
- 재사용X 특정 위치에서만 사용할 기능에 대해서 익명 객체로 구현 多

## [익명 자식 객체]

## 부모타입 변수 = new 부모생성자(매개값) { ... };

## [익명 구현 객체]

## 인터페이스타입 변수 = new 인터페이스() { ... };

**<사용>**

    **(부모,인터페이스 타입) 으로 선언된 변수 ← 즉시 대입시켜서 바로 기능 연결 구현 O**

- 필드 변수 <- 바로 익명 객체 대입
- 메소드 내 로컬 변수 <- 바로 익명 객체 대입
- 메소드의 매개변수 <- 익명 객체 대입

# 09-6. 람다식

# **[람다식]**

- 이름 없는 메소드 (간결 작성 메소드)
- 다른 메소드의 매개변수로 ‘메소드’ 전달할 경우, 람다식으로 간단히 전달 가능
- 메소드 한 번만 사용 + 내용 짧은 경우에 유용
- 매개변수로 람다식 대입 -> 해당 메소드 실행 내부에서 바로 람다식 기능 사용 O
- ?: 객체를 매개값으로 받는 메소드의 매개변수에 람다식 연결 시 → 람다식(메소드) 전달되어 해당 객체 실행된다.

```
<기본 구조>

(매개변수1, 매개변수2...) -> { 실행부(반환값처리) };
```

# [람다식 특징]

## **>> 매개변수**

- 0개 이상 가짐
- ()괄호로 묶여서 쉼표로 구분함
- () : 매개변수 없음
- 단일 매개변수의 경우 괄호 생략 가능O

## >> 람다식 본문 { } 실행부

- 0개 이상의 문장 가짐
- 단일 문장은 {}중괄호 생략 가능O
- 하나 이상의 문장은 반드시 {}중괄호 묶음

# 09-7. 함수 인터페이스와 람다식

# [함수 인터페이스 ]

- 하나의 추상 메소드만 선언해 놓은 인터페이스

ex)  Runnable 인터페이스 안에는 run() 추상메소드 1개만 선언됨 : 함수 인터페이스

- 함수 인터페이스 타입 변수 ← 람다식 대입 시, 람다식은 함수 인터페이스 타입으로 자동 타입 변환되어 main에서 해당 인터페이스의 추상 메소드 호출할 때 람다식 내용이 실행됨

```java
interface MyInterface { //함수 인터페이스

		void sayHello(); //추상 메소드 1개

}

public class LamdaTest {

		public static void main(String[] args) {

		MyInterface a = () -> System.out.println(“Hello Lamda!”);

		a.sayHello(); //추상메소드 호출 -> 대입된 람다식 내용이 호출됨

	}

}
```